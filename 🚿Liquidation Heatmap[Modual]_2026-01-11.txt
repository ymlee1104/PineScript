//@version=6
indicator("üöøLiquidation Heatmap + Strategy [Expert]", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=100)

// =============================================================================
// [MODULE 0] ZigZag Trend_Color Inputs 
// =============================================================================
grp_zigzag = "Zig Zag Line"
useZig = input.bool(true, "ZigZag", inline='zigzag', group=grp_zigzag)
Zigdev = input.float(1.7, "Ïù¥Í≤©", step=0.1, inline='zigzag', group=grp_zigzag) / 100
Zigthk = input.int(3, "ÎëêÍªò", inline='zigzag', group=grp_zigzag)
ZigtxtSz = input.string(size.normal, "ÌÅ¨Í∏∞", options=[size.tiny, size.small, size.normal, size.large], inline='zigzag', group=grp_zigzag)

// =============================================================================
// [MODULE 1] CONFIGURATION & INPUTS
// =============================================================================
grp_disp    = "Show: Display Settings"
showInd     = input.bool(true, "Indicator", inline='sh', group=grp_disp)
keepTouch   = input.bool(false, "Touched Pockets", inline='sh', group=grp_disp)
showScale   = input.bool(false, "Scale", inline='sh', group=grp_disp)
extBars     = input.int(0, "Bar Extension", minval=0, inline='sh', group=grp_disp)

grp_calc    = "Calculation Logic"
calcMode    = input.string("Vol x Range", "Calculation Mode", options=["Volume", "Range", "Vol x Range"], inline='cal1', group=grp_calc)
lookback    = input.int(480, "Lookback Length", minval=100, maxval=5000, inline='cal1', group=grp_calc)
minIntensity= input.float(0.0, "Min Intensity (M)", step=0.1, inline='inten', group=grp_calc) * 1000000
mergeDist   = input.float(0.1, "Label Merge %", step=0.01, inline='inten', group=grp_calc)
atrLen      = input.int(1440, "ATR Period", inline='atr', group=grp_calc)
atrMult     = input.float(1.9, "ATR Band (%)", step=0.1, inline='atr', group=grp_calc) / 10.0
swing1      = input.int(2, "1st Swing Width (Sensitive)", minval=1, maxval=50, group=grp_calc, tooltip="Îã®Í∏∞Ï†ÅÏù∏ 'Ï†ÑÏà†Ï†Å' ÏßÑÏûÖ/Ï≤≠ÏÇ∞ ÏûêÎ¶¨Î•º Ï∞æÏäµÎãàÎã§. Í∞íÏù¥ ÏûëÏùÑÏàòÎ°ù ÎØºÍ∞êÌï©ÎãàÎã§.")
swing2      = input.int(10, "2nd Swing Width (Robust)", minval=0, maxval=50, group=grp_calc, tooltip="Ïû•Í∏∞Ï†ÅÏù∏ 'Ï†ÑÎûµÏ†Å' Ï£ºÏöî ÏßÄÏßÄ/Ï†ÄÌï≠ ÎùºÏù∏ÏùÑ Ï∞æÏäµÎãàÎã§.")

grp_style   = "Style & Colors"
useManScale = input.bool(true, "Use Custom Scale", inline='st0', group=grp_style)
valMax      = input.float(25.0, "Scale Max (M)", inline='sc1', group=grp_style) * 1000000
valMin      = input.float(0.0, "Scale Min (M)", inline='sc1', group=grp_style) * 1000000
contrast    = input.float(0.1, "Auto Scale Contrast", step=0.1, inline='sc2', group=grp_style)
touchAlpha  = input.int(85, "Touched Transparency", minval=0, maxval=100, inline='sc2', group=grp_style)
colLong     = input.color(color.rgb(1, 203, 254, 1), "Long Color", inline='col', group=grp_style)
colShort    = input.color(color.rgb(254, 0, 220), "Short Color", inline='col', group=grp_style)
offsetPct   = input.float(0.00, "Price Offset (%)", step=0.05, inline='col', group=grp_style)

// =============================================================================
// [MODULE 6] REVERSAL ALERTS (STRATEGY INPUTS)
// =============================================================================
grp_alert   = "Strategy: Liquidation Reversal"
useStrat    = input.bool(false, "Show Reversal Signals", group=grp_alert)
liqLongP    = input.float(279.0, "Long Liq Price(Bottom)", inline='LiqP', group=grp_alert)
liqShortP   = input.float(289.0, "Short Liq Price(Top)", inline='LiqP', group=grp_alert)
liqLongR  = input.float(0.1, "Detection Dist (%) Long", step=0.1, inline='RangeW', group=grp_alert) / 100
liqShortR = input.float(0.1, "/ (%) Short", step=0.1, inline='RangeW', group=grp_alert) / 100

// ==============================================================================
// [MODULE 0] ZigZag Trend_Color Calculation 
// ==============================================================================
var line lLine = na, var label lLbl = na, var int dir = 0 
var float lastP = close, var float startP = close, var int lastIdx = bar_index

if useZig 
    bool isUp = dir >= 0
    float target = isUp ? high : low
    bool extCond = isUp ? high > lastP : low < lastP
    bool revCond = isUp ? low < lastP * (1 - Zigdev) : high > lastP * (1 + Zigdev)

    if extCond 
        lastP := target, lastIdx := bar_index
        line.set_xy2(lLine, lastIdx, lastP), label.set_xy(lLbl, lastIdx, lastP)
        label.set_text(lLbl, str.tostring((lastP - startP) / startP * 100, format.percent))
        
    else if revCond 
        startP := lastP, lastP := isUp ? low : high 
        color c = isUp ? color.red : color.green 
        lLine := line.new(lastIdx, startP, bar_index, lastP, color=c, width=Zigthk)
        lLbl  := label.new(bar_index, lastP, str.tostring((lastP-startP)/startP*100, format.percent),
                 style=isUp?label.style_label_up:label.style_label_down, color=color.new(color.white,100), textcolor=c, size=ZigtxtSz)
        lastIdx := bar_index, dir := isUp ? -1 : 1 

// =============================================================================
// [MODULE 2] DATA STRUCTURES (TYPES)
// =============================================================================
type Pocket
    box     id          
    int     startTime   
    int     startBar    
    float   top         
    float   bot         
    float   vol         
    int     side        
    bool    isHit       
    bool    isFrozen    
    int     frozenTime  

// =============================================================================
// [MODULE 3] UTILITY & VISUALIZATION
// =============================================================================
method formatVolume(float val) =>
    string res = ""
    if val >= 1000000000
        res := str.tostring(val / 1000000000, "#,###.#") + "B"
    else if val >= 1000000
        res := str.tostring(val / 1000000, "#,###.#") + "M"
    else if val >= 1000
        res := str.tostring(val / 1000, "#,###.#") + "K"
    else
        res := str.tostring(val, "#,###.#")
    res

calcHeatColor(float w, int side, float vMin, float vMax, bool isTouched) =>
    baseColor = side == 1 ? colLong : colShort
    safeMax = math.max(vMax, vMin + 1.0)
    rng     = safeMax - vMin
    norm    = rng != 0 ? math.max(0.0, math.min((w - vMin) / rng, 1.0)) : 0.0
    effContrast = useManScale ? 1.0 : contrast
    adj         = math.pow(norm, effContrast)
    finalCol    = color.from_gradient(adj, 0.0, 1.0, color.new(baseColor, 90), color.new(baseColor, 0))
    if isTouched
        color.new(baseColor, touchAlpha)
    else
        finalCol

// =============================================================================
// [MODULE 4] POCKET MANAGER (METHODS)
// =============================================================================
var array<Pocket> pockets = array.new<Pocket>()
method update(Pocket this, float vMin, float vMax, int currentBar, int currentTime, int tDelta) =>
    bool shouldDelete = (currentBar - this.startBar) > lookback
    if not shouldDelete
        if not this.isFrozen
            this.id.set_left(this.startTime)
            this.id.set_right(currentTime + tDelta * extBars)
        else
            this.id.set_right(this.frozenTime)
        
        col = calcHeatColor(this.vol, this.side, vMin, vMax, this.isHit)
        this.id.set_bgcolor(col)
        if this.isHit
            this.id.set_border_color(color.new(col, touchAlpha))
        else
            this.id.set_border_color(na)
    shouldDelete

method checkTouch(Pocket this, float highPrice, float lowPrice, int currentTime) =>
    bool touched = false
    if not this.isHit and not this.isFrozen
        mid = (this.top + this.bot) * 0.5
        if (this.side == 1 and lowPrice <= mid) or (this.side == -1 and highPrice >= mid)
            touched := true
            if keepTouch
                this.isHit      := true
                this.isFrozen   := true
                this.frozenTime := currentTime
                this.id.set_right(currentTime)
            else
                this.isHit := true 
    touched

isDuplicateEvent(int barIdx, int side) =>
    bool found = false
    if pockets.size() > 0
        for i = pockets.size() - 1 to 0
            p = pockets.get(i)
            if p.startBar == barIdx and p.side == side
                found := true
                break
    found

addPocket(float rawPrice, int width, int side, float srcVal, float band, float vMin, float vMax) =>
    if not na(rawPrice)
        if srcVal >= minIntensity 
            targetBar = bar_index - width 
            
            if not isDuplicateEvent(targetBar, side)
                basePrice = side == -1 ? rawPrice * (1 + offsetPct / 100.0) : rawPrice * (1 - offsetPct / 100.0)
                topP      = side == -1 ? basePrice + band : basePrice
                botP      = side == -1 ? basePrice : basePrice - band
                
                b = box.new(time[width], topP, time, botP, xloc=xloc.bar_time, border_color=na)
                p = Pocket.new(b, time[width], targetBar, topP, botP, srcVal, side, false, false, na)
                pockets.push(p)

// =============================================================================
// [MODULE 5] MAIN EXECUTION & AGGREGATION
// =============================================================================
var table scaleTbl = table.new(position.middle_right, 1, 24)
if showInd
    rangeM = (high - low) * 100.0
    volM   = ta.cum(volume) <= 1 ? rangeM : volume
    liqM   = switch calcMode
        "Range"       => rangeM
        "Vol x Range" => volM * rangeM
        => volM

    ph1 = ta.pivothigh(high, swing1, swing1)
    pl1 = ta.pivotlow(low, swing1, swing1)
    
    ph2 = ta.pivothigh(high, swing2, swing2)
    pl2 = ta.pivotlow(low, swing2, swing2)

    autoMax = nz(ta.highest(liqM, lookback), liqM)
    autoMin = nz(ta.lowest(liqM, lookback), liqM)
    if autoMin == autoMax
        autoMin := autoMin * 0.9
    
    curMax = useManScale ? valMax : autoMax
    curMin = useManScale ? valMin : autoMin
    curBand = ta.atr(atrLen) * atrMult

    addPocket(ph1, swing1, -1, liqM[swing1], curBand, curMin, curMax)
    addPocket(pl1, swing1,  1, liqM[swing1], curBand, curMin, curMax)
    
    if swing2 > 0 and swing2 != swing1
        addPocket(ph2, swing2, -1, liqM[swing2], curBand, curMin, curMax)
        addPocket(pl2, swing2,  1, liqM[swing2], curBand, curMin, curMax)

    int tDelta = nz(time - time[1], 0)

    int pSize = pockets.size()
    if pSize > 0
        for i = pSize - 1 to 0
            if i < pockets.size()
                p = pockets.get(i)
                isTouchedNow = p.checkTouch(high, low, time)
                killByTouch  = isTouchedNow and not keepTouch
                killByAge    = p.update(curMin, curMax, bar_index, time, tDelta)
                
                if killByTouch or killByAge
                    p.id.delete()
                    pockets.remove(i)

    if barstate.islast
        if showScale
            table.cell(scaleTbl, 0, 0, "Max\n" + curMax.formatVolume(), text_color=color.white, bgcolor=color.new(color.black, 80), text_size=size.small)
            for i = 1 to 22
                c = color.from_gradient(i - 1, 0, 21, color.new(colShort, 5), color.new(colLong, 5))
                table.cell(scaleTbl, 0, i, "", bgcolor=c, height=1.5)
            table.cell(scaleTbl, 0, 23, "Min\n" + curMin.formatVolume(), text_color=color.white, bgcolor=color.new(color.black, 80), text_size=size.small)
        else
            table.clear(scaleTbl, 0, 0, 0, 23)

        var label[] activeLabels = array.new<label>()
        var box[]   mergedBoxes  = array.new<box>()
        for l in activeLabels
            l.delete()
        activeLabels.clear()
        for b in mergedBoxes
            b.delete()
        mergedBoxes.clear()

        float[] yList = array.new<float>()
        int[]   idxList = array.new<int>()
        
        int pLen = pockets.size()
        
        if pLen > 0 
            for i = 0 to pLen - 1
                p = pockets.get(i)
                if not p.isHit
                    yList.push((p.top + p.bot) / 2)
                    idxList.push(i)

        if yList.size() > 0
            sortedIndices = yList.sort_indices()
            firstIdx = sortedIndices.get(0)
            pFirst   = pockets.get(idxList.get(firstIdx))
            
            grpVol = pFirst.vol
            grpTop = pFirst.top
            grpBot = pFirst.bot
            grpY   = (grpTop + grpBot) / 2
            grpSide= pFirst.side
            
            for k = 0 to sortedIndices.size() - 1
                isLastItem = (k == sortedIndices.size() - 1)
                
                if not isLastItem
                    nextK   = k + 1
                    nextIdx = sortedIndices.get(nextK)
                    realIdx = idxList.get(nextIdx)
                    pNext   = pockets.get(realIdx)
                    
                    nextY   = (pNext.top + pNext.bot) / 2
                    dist    = math.abs(nextY - grpY) / close * 100
                    
                    if dist <= mergeDist
                        grpVol  += pNext.vol
                        grpTop  := math.max(grpTop, pNext.top)
                        grpBot  := math.min(grpBot, pNext.bot)
                        grpY    := ((grpY * (grpVol - pNext.vol)) + (nextY * pNext.vol)) / grpVol
                        if pNext.vol > (grpVol - pNext.vol) 
                            grpSide := pNext.side
                        pNext.id.set_right(time)
                    else
                        fCol = calcHeatColor(grpVol, grpSide, curMin, curMax, false)
                        lx   = time + nz(time - time[1], 0) * (extBars + 1)
                        mb   = box.new(time, grpTop, lx, grpBot, xloc=xloc.bar_time, border_color=na, bgcolor=fCol)
                        mergedBoxes.push(mb)
                        lbl  = label.new(lx, grpY, grpVol.formatVolume(), xloc=xloc.bar_time, yloc=yloc.price, color=fCol, style=label.style_label_left, textcolor=color.white, size=size.normal)
                        activeLabels.push(lbl)
                        
                        grpVol := pNext.vol
                        grpTop := pNext.top
                        grpBot := pNext.bot
                        grpY   := nextY
                        grpSide:= pNext.side
                        pNext.id.set_right(time)
                else
                    fCol = calcHeatColor(grpVol, grpSide, curMin, curMax, false)
                    lx   = time + nz(time - time[1], 0) * (extBars + 1)
                    mb   = box.new(time, grpTop, lx, grpBot, xloc=xloc.bar_time, border_color=na, bgcolor=fCol)
                    mergedBoxes.push(mb)
                    lbl  = label.new(lx, grpY, grpVol.formatVolume(), xloc=xloc.bar_time, yloc=yloc.price, color=fCol, style=label.style_label_left, textcolor=color.white, size=size.normal)
                    activeLabels.push(lbl)

// =============================================================================
// [MODULE 7] STRATEGY LOGIC & ALERTS (CORRECTED)
// =============================================================================

// 1. Long Reversal Logic (Catch the Falling Knife)
longZoneTop = liqLongP * (1 + liqLongR)
longZoneBot = liqLongP * (1 - liqLongR)

isLongTouch = low <= longZoneTop // Zone ÌÑ∞Ïπò
isBullCandle= close > open      // ÏñëÎ¥â ÎßàÍ∞ê
hasTail     = (open - low) > (close - open) * 0.3 // Íº¨Î¶¨Í∞Ä Î™∏ÌÜµÏùò 30% Ïù¥ÏÉÅ

condLong = useStrat and isLongTouch and isBullCandle and hasTail

// // [ÏãúÍ∞ÅÌôî Ï∂îÍ∞Ä] ÏÑ§Ï†ïÌïú Ï≤≠ÏÇ∞ Í∞ÄÍ≤©ÎåÄ ÎùºÏù∏ Í∑∏Î¶¨Í∏∞
// line.new(bar_index, condLong ? liqLongP : na, bar_index + 10, liqLongP, color=color.new(color.lime, 50), style=line.style_dotted, width=4)
// // Ïàè Ï≤≠ÏÇ∞ ÌÉÄÍ≤ü (Îπ®Í∞ÑÏÉâ Ï†êÏÑ†)
// line.new(bar_index, liqShortP, bar_index + 10, liqShortP, color=color.new(color.red, 50), style=line.style_dotted, width=4)

plotshape(condLong, "Long Reversal", shape.labelup, location.belowbar, color.lime, text="LONG!", textcolor=color.white)

// 2. Short Reversal Logic (Top Reversal)
shortZoneBot = liqShortP * (1 - liqShortR)
shortZoneTop = liqShortP * (1 + liqShortR)

isShortTouch = high >= shortZoneBot // Zone ÌÑ∞Ïπò
isBearCandle = close < open        // ÏùåÎ¥â ÎßàÍ∞ê
hasUpTail    = (high - open) > (open - close) * 0.3 // ÏúóÍº¨Î¶¨ Î∞úÏÉù

condShort = useStrat and isShortTouch and isBearCandle and hasUpTail

plotshape(condShort, "Short Reversal", shape.labeldown, location.abovebar, color.red, text="SHORT!", textcolor=color.white)

// 3. Alerts
alertcondition(condLong, "Liquidation Buy Signal", "Price touched Long Liq Level & Reversing Up!")
alertcondition(condShort, "Liquidation Sell Signal", "Price touched Short Liq Level & Reversing Down!")


// =============================================================================
// [ÏãúÍ∞ÅÌôî Ï∂îÍ∞Ä] Ï≤≠ÏÇ∞ Î™©ÌëúÍ∞Ä ÎùºÏù∏ Í∑∏Î¶¨Í∏∞ (ÏµúÏ†ÅÌôî Î≤ÑÏ†Ñ)
// =============================================================================
// ÎùºÏù∏ Í∞ùÏ≤¥Î•º Ï†ÄÏû•Ìï† Î≥ÄÏàò (var ÌÇ§ÏõåÎìúÎ°ú ÏÉÅÌÉú Ïú†ÏßÄ)
var line lineL = na
var line lineS = na

// 1. ÎßàÏßÄÎßâ Î¥âÏóêÏÑúÎßå Ïã§Ìñâ (Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏)
// 2. useStrat(Ï†ÑÎûµ Î≥¥Í∏∞)Í∞Ä ÏºúÏ†∏ ÏûàÏùÑ ÎïåÎßå Ïã§Ìñâ
if barstate.islast and useStrat
    // Í∏∞Ï°¥ ÎùºÏù∏Ïù¥ ÏûàÎã§Î©¥ ÏÇ≠Ï†ú (ÏûîÏÉÅ Ï†úÍ±∞ Ïï†ÎãàÎ©îÏù¥ÏÖò Ìö®Í≥º)
    line.delete(lineL)
    line.delete(lineS)
    
    // Î°± Ï≤≠ÏÇ∞ ÌÉÄÍ≤ü ÎùºÏù∏ (Ï¥àÎ°ùÏÉâ Ï†êÏÑ†)
    lineL := line.new(bar_index, liqLongP, bar_index + 10, liqLongP, color=color.new(color.lime, 30), style=line.style_dotted, width=4)
    
    // Ïàè Ï≤≠ÏÇ∞ ÌÉÄÍ≤ü ÎùºÏù∏ (Îπ®Í∞ÑÏÉâ Ï†êÏÑ†)
    lineS := line.new(bar_index, liqShortP, bar_index + 10, liqShortP, color=color.new(color.red, 30), style=line.style_dotted, width=4)