//@version=6
indicator("ğŸš¿Liquidation Heatmap + Strategy [Expert]", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=100)

// =============================================================================
// [MODULE 0] ZigZag Trend_Color Inputs 
// =============================================================================
grp_zigzag = "Zig Zag Line"
useZig = input.bool(true, "ZigZag", inline='zigzag', group=grp_zigzag)
Zigdev = input.float(0.3, "ì´ê²©", step=0.1, inline='zigzag', group=grp_zigzag) / 100
Zigthk = input.int(3, "ë‘ê»˜", inline='zigzag', group=grp_zigzag)
ZigtxtSz = input.string(size.normal, "í¬ê¸°", options=[size.tiny, size.small, size.normal, size.large], inline='zigzag', group=grp_zigzag)

// =============================================================================
// [MODULE 1] CONFIGURATION & INPUTS
// =============================================================================
grp_disp    = "Show: Display Settings"
showInd     = input.bool(true, "Indicator", inline='sh', group=grp_disp)
keepTouch   = input.bool(false, "Touched Pockets", inline='sh', group=grp_disp)
showScale   = input.bool(false, "Scale", inline='sh', group=grp_disp)
extBars     = input.int(0, "Bar Extension", minval=0, inline='sh', group=grp_disp)

grp_calc    = "Calculation Logic"
calcMode    = input.string("Vol x Range", "Calculation Mode", options=["Volume", "Range", "Vol x Range"], inline='cal1', group=grp_calc)
lookback    = input.int(480, "Lookback Length", minval=100, maxval=5000, inline='cal1', group=grp_calc)
minIntensity= input.float(0.0, "Min Intensity (M)", step=0.1, inline='inten', group=grp_calc) * 1000000
mergeDist   = input.float(0.1, "Label Merge %", step=0.01, inline='inten', group=grp_calc)
atrLen      = input.int(1440, "ATR Period", inline='atr', group=grp_calc)
atrMult     = input.float(1.9, "ATR Band (%)", step=0.1, inline='atr', group=grp_calc) / 10.0
swing1      = input.int(1, "1st Swing Width (Sensitive)", minval=1, maxval=50, group=grp_calc, tooltip="ë‹¨ê¸°ì ì¸ 'ì „ìˆ ì ' ì§„ì…/ì²­ì‚° ìë¦¬ë¥¼ ì°¾ìŠµë‹ˆë‹¤. ê°’ì´ ì‘ì„ìˆ˜ë¡ ë¯¼ê°í•©ë‹ˆë‹¤.")
swing2      = input.int(10, "2nd Swing Width (Robust)", minval=0, maxval=50, group=grp_calc, tooltip="ì¥ê¸°ì ì¸ 'ì „ëµì ' ì£¼ìš” ì§€ì§€/ì €í•­ ë¼ì¸ì„ ì°¾ìŠµë‹ˆë‹¤.")

grp_style   = "Style & Colors"
useManScale = input.bool(true, "Use Custom Scale", inline='st0', group=grp_style)
valMax      = input.float(10.0, "Scale Max (M)", inline='sc1', group=grp_style) * 1000000
valMin      = input.float(0.0, "Scale Min (M)", inline='sc1', group=grp_style) * 1000000
contrast    = input.float(0.1, "Auto Scale Contrast", step=0.1, inline='sc2', group=grp_style)
touchAlpha  = input.int(85, "Touched Transparency", minval=0, maxval=100, inline='sc2', group=grp_style)
colLong     = input.color(color.rgb(1, 203, 254, 1), "Long Color", inline='col', group=grp_style)
colShort    = input.color(color.rgb(254, 0, 220), "Short Color", inline='col', group=grp_style)
offsetPct   = input.float(0.00, "Price Offset (%)", step=0.05, inline='col', group=grp_style)

// =============================================================================
// [MODULE 6] Manual Liquidation Lines (Inputs)
// =============================================================================
grp_alert    = "Alert & Liquidation Levels"
showLiqLines = input.bool(true, "", inline='LiqP0', group=grp_alert)
start_time  = input.time(timestamp("2026-01-11 20:11 +0900"), 'ì‹œì‘', inline='LiqP0', group=grp_alert)
show_length  = input.int(15, "Length", inline='LiqP0', group=grp_alert)

liqLongPFrom = input.float(277.0, "Long Liq Price(From)", step=0.1, inline='LiqP1', group=grp_alert)
liqLongPTo   = input.float(276.0, "(To)Long Liq Price", step=0.1, inline='LiqP2', group=grp_alert)
liqShortPFrom= input.float(285.0, "Short Liq Price(From)", step=0.1, inline='LiqP1', group=grp_alert)
liqShortPTo  = input.float(286.0, "(To)Short Liq Price", step=0.1, inline='LiqP2', group=grp_alert)
inDate      = time >= start_time

// ==============================================================================
// [MODULE 0] ZigZag Trend_Color Calculation 
// ==============================================================================
var line lLine = na, var label lLbl = na, var int dir = 0 
var float lastP = close, var float startP = close, var int lastIdx = bar_index

if useZig 
    bool isUp = dir >= 0
    float target = isUp ? high : low
    bool extCond = isUp ? high > lastP : low < lastP
    bool revCond = isUp ? low < lastP * (1 - Zigdev) : high > lastP * (1 + Zigdev)

    if extCond 
        lastP := target, lastIdx := bar_index
        line.set_xy2(lLine, lastIdx, lastP), label.set_xy(lLbl, lastIdx, lastP)
        label.set_text(lLbl, str.tostring((lastP - startP) / startP * 100, format.percent))
        
    else if revCond 
        startP := lastP, lastP := isUp ? low : high 
        color c = isUp ? color.red : color.green 
        lLine := line.new(lastIdx, startP, bar_index, lastP, color=c, width=Zigthk)
        lLbl  := label.new(bar_index, lastP, str.tostring((lastP-startP)/startP*100, format.percent),
                 style=isUp?label.style_label_up:label.style_label_down, color=color.new(color.white,100), textcolor=c, size=ZigtxtSz)
        lastIdx := bar_index, dir := isUp ? -1 : 1 

// =============================================================================
// [MODULE 2] DATA STRUCTURES (TYPES)
// =============================================================================
type Pocket
    box     id          
    int     startTime   
    int     startBar    
    float   top         
    float   bot         
    float   vol         
    int     side        
    bool    isHit       
    bool    isFrozen    
    int     frozenTime  

// =============================================================================
// [MODULE 3] UTILITY & VISUALIZATION
// =============================================================================
method formatVolume(float val) =>
    string res = ""
    if val >= 1000000000
        res := str.tostring(val / 1000000000, "#,###.#") + "B"
    else if val >= 1000000
        res := str.tostring(val / 1000000, "#,###.#") + "M"
    else if val >= 1000
        res := str.tostring(val / 1000, "#,###.#") + "K"
    else
        res := str.tostring(val, "#,###.#")
    res

calcHeatColor(float w, int side, float vMin, float vMax, bool isTouched) =>
    baseColor = side == 1 ? colLong : colShort
    safeMax = math.max(vMax, vMin + 1.0)
    rng     = safeMax - vMin
    norm    = rng != 0 ? math.max(0.0, math.min((w - vMin) / rng, 1.0)) : 0.0
    effContrast = useManScale ? 1.0 : contrast
    adj         = math.pow(norm, effContrast)
    finalCol    = color.from_gradient(adj, 0.0, 1.0, color.new(baseColor, 90), color.new(baseColor, 0))
    if isTouched
        color.new(baseColor, touchAlpha)
    else
        finalCol

// =============================================================================
// [MODULE 4] POCKET MANAGER (METHODS)
// =============================================================================
var array<Pocket> pockets = array.new<Pocket>()
method update(Pocket this, float vMin, float vMax, int currentBar, int currentTime, int tDelta) =>
    bool shouldDelete = (currentBar - this.startBar) > lookback
    if not shouldDelete
        if not this.isFrozen
            this.id.set_left(this.startTime)
            this.id.set_right(currentTime + tDelta * extBars)
        else
            this.id.set_right(this.frozenTime)
        
        col = calcHeatColor(this.vol, this.side, vMin, vMax, this.isHit)
        this.id.set_bgcolor(col)
        if this.isHit
            this.id.set_border_color(color.new(col, touchAlpha))
        else
            this.id.set_border_color(na)
    shouldDelete

method checkTouch(Pocket this, float highPrice, float lowPrice, int currentTime) =>
    bool touched = false
    if not this.isHit and not this.isFrozen
        mid = (this.top + this.bot) * 0.5
        if (this.side == 1 and lowPrice <= mid) or (this.side == -1 and highPrice >= mid)
            touched := true
            if keepTouch
                this.isHit      := true
                this.isFrozen   := true
                this.frozenTime := currentTime
                this.id.set_right(currentTime)
            else
                this.isHit := true 
    touched

isDuplicateEvent(int barIdx, int side) =>
    bool found = false
    if pockets.size() > 0
        for i = pockets.size() - 1 to 0
            p = pockets.get(i)
            if p.startBar == barIdx and p.side == side
                found := true
                break
    found

addPocket(float rawPrice, int width, int side, float srcVal, float band, float vMin, float vMax) =>
    if not na(rawPrice)
        if srcVal >= minIntensity 
            targetBar = bar_index - width 
            
            if not isDuplicateEvent(targetBar, side)
                basePrice = side == -1 ? rawPrice * (1 + offsetPct / 100.0) : rawPrice * (1 - offsetPct / 100.0)
                topP      = side == -1 ? basePrice + band : basePrice
                botP      = side == -1 ? basePrice : basePrice - band
                
                b = box.new(time[width], topP, time, botP, xloc=xloc.bar_time, border_color=na)
                p = Pocket.new(b, time[width], targetBar, topP, botP, srcVal, side, false, false, na)
                pockets.push(p)

// =============================================================================
// [MODULE 5] MAIN EXECUTION & AGGREGATION
// =============================================================================
var table scaleTbl = table.new(position.middle_right, 1, 24)
if showInd
    rangeM = (high - low) * 100.0
    volM   = ta.cum(volume) <= 1 ? rangeM : volume
    liqM   = switch calcMode
        "Range"       => rangeM
        "Vol x Range" => volM * rangeM
        => volM

    ph1 = ta.pivothigh(high, swing1, swing1)
    pl1 = ta.pivotlow(low, swing1, swing1)
    
    ph2 = ta.pivothigh(high, swing2, swing2)
    pl2 = ta.pivotlow(low, swing2, swing2)

    autoMax = nz(ta.highest(liqM, lookback), liqM)
    autoMin = nz(ta.lowest(liqM, lookback), liqM)
    if autoMin == autoMax
        autoMin := autoMin * 0.9
    
    curMax = useManScale ? valMax : autoMax
    curMin = useManScale ? valMin : autoMin
    curBand = ta.atr(atrLen) * atrMult

    addPocket(ph1, swing1, -1, liqM[swing1], curBand, curMin, curMax)
    addPocket(pl1, swing1,  1, liqM[swing1], curBand, curMin, curMax)
    
    if swing2 > 0 and swing2 != swing1
        addPocket(ph2, swing2, -1, liqM[swing2], curBand, curMin, curMax)
        addPocket(pl2, swing2,  1, liqM[swing2], curBand, curMin, curMax)

    int tDelta = nz(time - time[1], 0)

    int pSize = pockets.size()
    if pSize > 0
        for i = pSize - 1 to 0
            if i < pockets.size()
                p = pockets.get(i)
                isTouchedNow = p.checkTouch(high, low, time)
                killByTouch  = isTouchedNow and not keepTouch
                killByAge    = p.update(curMin, curMax, bar_index, time, tDelta)
                
                if killByTouch or killByAge
                    p.id.delete()
                    pockets.remove(i)

    if barstate.islast
        if showScale
            table.cell(scaleTbl, 0, 0, "Max\n" + curMax.formatVolume(), text_color=color.white, bgcolor=color.new(color.black, 80), text_size=size.small)
            for i = 1 to 22
                c = color.from_gradient(i - 1, 0, 21, color.new(colShort, 5), color.new(colLong, 5))
                table.cell(scaleTbl, 0, i, "", bgcolor=c, height=1.5)
            table.cell(scaleTbl, 0, 23, "Min\n" + curMin.formatVolume(), text_color=color.white, bgcolor=color.new(color.black, 80), text_size=size.small)
        else
            table.clear(scaleTbl, 0, 0, 0, 23)

        var label[] activeLabels = array.new<label>()
        var box[]   mergedBoxes  = array.new<box>()
        for l in activeLabels
            l.delete()
        activeLabels.clear()
        for b in mergedBoxes
            b.delete()
        mergedBoxes.clear()

        float[] yList = array.new<float>()
        int[]   idxList = array.new<int>()
        
        int pLen = pockets.size()
        
        if pLen > 0 
            for i = 0 to pLen - 1
                p = pockets.get(i)
                if not p.isHit
                    yList.push((p.top + p.bot) / 2)
                    idxList.push(i)

        if yList.size() > 0
            sortedIndices = yList.sort_indices()
            firstIdx = sortedIndices.get(0)
            pFirst   = pockets.get(idxList.get(firstIdx))
            
            grpVol = pFirst.vol
            grpTop = pFirst.top
            grpBot = pFirst.bot
            grpY   = (grpTop + grpBot) / 2
            grpSide= pFirst.side
            
            for k = 0 to sortedIndices.size() - 1
                isLastItem = (k == sortedIndices.size() - 1)
                
                if not isLastItem
                    nextK   = k + 1
                    nextIdx = sortedIndices.get(nextK)
                    realIdx = idxList.get(nextIdx)
                    pNext   = pockets.get(realIdx)
                    
                    nextY   = (pNext.top + pNext.bot) / 2
                    dist    = math.abs(nextY - grpY) / close * 100
                    
                    if dist <= mergeDist
                        grpVol  += pNext.vol
                        grpTop  := math.max(grpTop, pNext.top)
                        grpBot  := math.min(grpBot, pNext.bot)
                        grpY    := ((grpY * (grpVol - pNext.vol)) + (nextY * pNext.vol)) / grpVol
                        if pNext.vol > (grpVol - pNext.vol) 
                            grpSide := pNext.side
                        pNext.id.set_right(time)
                    else
                        fCol = calcHeatColor(grpVol, grpSide, curMin, curMax, false)
                        lx   = time + nz(time - time[1], 0) * (extBars + 1)
                        mb   = box.new(time, grpTop, lx, grpBot, xloc=xloc.bar_time, border_color=na, bgcolor=fCol)
                        mergedBoxes.push(mb)
                        lbl  = label.new(lx, grpY, grpVol.formatVolume(), xloc=xloc.bar_time, yloc=yloc.price, color=fCol, style=label.style_label_left, textcolor=color.white, size=size.normal)
                        activeLabels.push(lbl)
                        
                        grpVol := pNext.vol
                        grpTop := pNext.top
                        grpBot := pNext.bot
                        grpY   := nextY
                        grpSide:= pNext.side
                        pNext.id.set_right(time)
                else
                    fCol = calcHeatColor(grpVol, grpSide, curMin, curMax, false)
                    lx   = time + nz(time - time[1], 0) * (extBars + 1)
                    mb   = box.new(time, grpTop, lx, grpBot, xloc=xloc.bar_time, border_color=na, bgcolor=fCol)
                    mergedBoxes.push(mb)
                    lbl  = label.new(lx, grpY, grpVol.formatVolume(), xloc=xloc.bar_time, yloc=yloc.price, color=fCol, style=label.style_label_left, textcolor=color.white, size=size.normal)
                    activeLabels.push(lbl)


// =============================================================================
// [MODULE 6] Manual Liquidation Lines (Drawing)
// =============================================================================
// ê°ì²´ ì´ˆê¸°í™” (ë°•ìŠ¤ 2ê°œ, ë¼ì¸ 1ê°œ) - í•œ ë²ˆë§Œ ìƒì„±í•˜ê³  ìœ„ì¹˜ë§Œ ì—…ë°ì´íŠ¸
var box bLong  = box.new(na, na, na, na, xloc=xloc.bar_index, border_style=line.style_solid)
var box bShort = box.new(na, na, na, na, xloc=xloc.bar_index, border_style=line.style_solid)
var line lMid  = line.new(na, na, na, na, xloc=xloc.bar_index, style=line.style_dotted)

// ë§ˆì§€ë§‰ ë´‰ì—ì„œë§Œ ì—…ë°ì´íŠ¸ (ì‹¤ì‹œê°„ ì´ë™)
if barstate.islast
    if showLiqLines
        // 1. Long Box (Cyan)
        // ì…ë ¥ê°’ ì¤‘ í° ê°’ì´ Top, ì‘ì€ ê°’ì´ Bottomì´ ë˜ë„ë¡ ìë™ ì •ë ¬
        float lTop = math.max(liqLongPFrom, liqLongPTo)
        float lBot = math.min(liqLongPFrom, liqLongPTo)
        
        box.set_lefttop(bLong, bar_index, lTop)
        box.set_rightbottom(bLong, bar_index + show_length, lBot)
        box.set_border_color(bLong, color.teal)
        box.set_bgcolor(bLong, color.new(color.teal, 85)) // ë‚´ë¶€ íˆ¬ëª…ë„ 85%

        // 2. Short Box (Magenta)
        float sTop = math.max(liqShortPFrom, liqShortPTo)
        float sBot = math.min(liqShortPFrom, liqShortPTo)
        
        box.set_lefttop(bShort, bar_index, sTop)
        box.set_rightbottom(bShort, bar_index + show_length, sBot)
        box.set_border_color(bShort, color.fuchsia)
        box.set_bgcolor(bShort, color.new(color.fuchsia, 85)) // ë‚´ë¶€ íˆ¬ëª…ë„ 85%

        // 3. Middle Line (Yellow Dotted)
        // liqLongPFromê³¼ liqShortPFromì˜ ì¤‘ê°„ê°’
        float midP = (liqLongPFrom + liqShortPFrom) / 2.0
        
        line.set_xy1(lMid, bar_index, midP)
        line.set_xy2(lMid, bar_index + show_length, midP)
        line.set_color(lMid, color.yellow)
        line.set_width(lMid, 7)

    else
        // ìˆ¨ê¹€ ì²˜ë¦¬ (Show Lines ì²´í¬ í•´ì œ ì‹œ)
        box.set_lefttop(bLong, na, na)
        box.set_rightbottom(bLong, na, na)
        box.set_lefttop(bShort, na, na)
        box.set_rightbottom(bShort, na, na)
        line.set_xy1(lMid, na, na)

// =============================================================================
// [MODULE 7] ALERTS & SIGNALS
// =============================================================================
// 1. ì§„ì… ì¡°ê±´ ì •ì˜ (ì‹œê°„ ì¡°ê±´ inDate ì¶”ê°€)
// ë¡± ì§„ì…: (í•˜í–¥ ëŒíŒŒ) AND (ì‹œì‘ì¼ ì´í›„)
bool isLongEntry = ta.crossunder(close, liqLongPFrom) and inDate

// ìˆ ì§„ì…: (ìƒí–¥ ëŒíŒŒ) AND (ì‹œì‘ì¼ ì´í›„)
bool isShortEntry = ta.crossover(close, liqShortPFrom) and inDate

// 2. ì°¨íŠ¸ ì‹œê°í™” (ì‹ í˜¸ ë°œìƒ ì‹œ í™”ì‚´í‘œ í‘œì‹œ)
// inDate ì¡°ê±´ì´ ì—†ìœ¼ë©´ ê³¼ê±° ì°¨íŠ¸ì—ë„ í™”ì‚´í‘œê°€ ëœ° ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì—¬ê¸°ì„œë„ isLongEntry ë³€ìˆ˜ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©
plotshape(isLongEntry, title="Long Entry Signal", style=shape.labelup, location=location.belowbar, color=color.teal, text="Long\nLiq", textcolor=color.white, size=size.small)
plotshape(isShortEntry, title="Short Entry Signal", style=shape.labeldown, location=location.abovebar, color=color.fuchsia, text="Short\nLiq", textcolor=color.white, size=size.small)

// 3. ì–¼ëŸ¬íŠ¸ ì¡°ê±´ ìƒì„± (ì„¤ì • ì°½ì—ì„œ ì„ íƒ ê°€ëŠ¥)
alertcondition(isLongEntry, title="â¤µEntry Long Liquidation Level", message="â¤µEntry Long Liquidation Level")
alertcondition(isShortEntry, title="â¤´Entry Short Liquidation Level", message="â¤´Entry Short Liquidation Level")

// 4. ë™ì  ì–¼ëŸ¬íŠ¸ (Any Alert Function Callìš©)
if isLongEntry
    alert("Long Entry! Price: " + str.tostring(close), alert.freq_once_per_bar_close)
if isShortEntry
    alert("Short Entry! Price: " + str.tostring(close), alert.freq_once_per_bar_close)