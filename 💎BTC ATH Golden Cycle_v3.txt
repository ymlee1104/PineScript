//@version=6
strategy("ğŸ’BTC ATH Golden Cycle_v4", overlay=true,
 initial_capital=70000, currency=currency.USDT, default_qty_value=100,
 default_qty_type=strategy.percent_of_equity, commission_value=0.05, pyramiding=5, backtest_fill_limits_assumption=1,
 slippage=1, margin_long=0, margin_short=0, calc_on_order_fills=false, calc_on_every_tick=false, use_bar_magnifier=true, process_orders_on_close=true)

// ============================================
// ğŸ•’ TIME RANGE
// ============================================
grp_time    = 'Time range'
start_time  = input.time(timestamp("2019-12-16 00:00 +0900"), 'ì‹œì‘ì¼', group=grp_time)
inDate      = time >= start_time

// ============================================
// âš¡ On/Off Switch
// ============================================
grp_sw      ='Indicator Switch'
show_ichi   = input.bool(true, 'ì¼ëª©ê· í˜•í‘œ', inline='sw', group=grp_sw)
showGMI     = input.bool(true, "Geometric Mean", inline='sw', group=grp_sw)
sd_enable   = input.bool(true, "Supply and Demand", inline='sw', group=grp_sw)

// ============================================
// 0. Ichimoku Inputs & Optimization
// ============================================
ichi_grp    = 'Neo-Ichimoku Cloud'
ichi_TKlen  = input.int(9, 'ì „í™˜ì„  ê¸°ê°„', minval=1, inline='ic1', group=ichi_grp) 
ichi_KJlen  = input.int(26, 'ê¸°ì¤€ì„  ê¸°ê°„', minval=1, inline='ic1', group=ichi_grp) 
ichi_SBlen  = input.int(52, 'ì„ í–‰ìŠ¤íŒ¬B ê¸°ê°„', minval=1, inline='ic2', group=ichi_grp) 
ichi_offset = input.int(1, 'ì‹¤í–‰ìŠ¤íŒ¬ ì˜¤í”„ì…‹', minval=1, inline='ic2', group=ichi_grp) 

// ============================================
// 1. BTC ATH Golden Cycle Inputs
// ============================================
grp_logic = "BTC ATH Golden Cycle Inputs"
max_drop_pct = input.float(75.0, "í•˜ë½ë¥ ", minval=1.0, step=1.0, inline='ath', group=grp_logic)
max_rise_pct = input.float(435.0, "ìƒìŠ¹ë¥ ", minval=10.0, step=1.0, inline='ath', group=grp_logic)
weight_val   = input.float(2.5, "ê°€ì¤‘ë¥ ", minval=0.1, step=0.1, inline='ath', group=grp_logic)

// ==========================================
// 2. Geometric Mean Inputs
// ==========================================
grp_gma='Geometric Mean'
gmiLength1 = input.int(14, "Geometric Fast Length", minval=1, inline='gmi', group=grp_gma)
gmiLength2 = input.int(56, "Slow Length", minval=1, inline='gmi', group=grp_gma)

// -----------------------------------------------------------------------------
// 3. Supply and Demand Zones INPUTS
// -----------------------------------------------------------------------------
grp_sd      = 'Supply and Demand (ì§€ì§€/ì €í•­) Settings'
sd_zone_len = input.int(20, "Zone Extension Length", minval = 1, inline='sd', group=grp_sd)
sd_h_mult   = input.float(0.9, "Box Height Multiplier", minval = 0.1, step = 0.1, inline='sd', group=grp_sd)
sd_col_sup  = input.color(color.orange, "Supply", inline='sd', group=grp_sd)
sd_col_dem  = input.color(#009fd4, "Demand", inline='sd', group=grp_sd)
sd_transp   = input.int(75, "íˆ¬ëª…BG", minval = 1, maxval = 100, inline='sd', group=grp_sd)
bd_transp   = input.int(55, "íˆ¬ëª…BD", minval = 1, maxval = 100, inline='sd', group=grp_sd)

// ============================================
// 0. Ichimoku Inputs & Optimization
// ============================================
float ichi_TK = na, float ichi_KJ = na, float ichi_SB = na, float ichi_SA = na, color ichi_color = na 
if show_ichi 
    ichi_TK := math.avg(ta.lowest(ichi_TKlen), ta.highest(ichi_TKlen)) 
    ichi_KJ := math.avg(ta.lowest(ichi_KJlen), ta.highest(ichi_KJlen)) 
    ichi_SB := math.avg(ta.lowest(ichi_SBlen), ta.highest(ichi_SBlen)) 
    ichi_SA := math.avg(ichi_TK, ichi_KJ) 
    ichi_color := ichi_SA > ichi_SB ? color.teal : color.fuchsia


// ==========================================
// 2. Geometric Mean Global Scope
// ==========================================
float gmi_ma1  = na
float gmi_ma2  = na
float gmi_mean = na
color gmi_trendCol = na

// ì „ëµ ì´ì‹ìš© ì§„ì… ì‹ í˜¸ ë³€ìˆ˜
bool gmi_isLong  = false
bool gmi_isShort = false

// Geometric Mean Optimization
if showGMI
    // ì´ë™í‰ê·  ê³„ì‚° (ë‹¨ìˆœ ì´ë™í‰ê·  SMA ì‚¬ìš©)
    gmi_ma1 := ta.sma(close, gmiLength1)
    gmi_ma2 := ta.sma(close, gmiLength2)
    gmi_mean := math.sqrt(gmi_ma1 * gmi_ma2)

    gmi_trendCol := (gmi_ma1 > gmi_mean and gmi_mean > gmi_ma2) ? color.aqua : 
                   (gmi_ma1 < gmi_mean and gmi_mean < gmi_ma2) ? color.fuchsia : na
    
    gmi_isLong  := gmi_ma1 > gmi_mean and gmi_mean > gmi_ma2
    gmi_isShort := gmi_ma1 < gmi_mean and gmi_mean < gmi_ma2

// -----------------------------------------------------------------------------
// 3. Supply and Demand Zones INPUTS GLOBAL STORAGE (Declared globally)
// -----------------------------------------------------------------------------
var sd_bear_boxes = array.new<box>()
var sd_bull_boxes = array.new<box>()
var sd_bear_delta = array.new<float>()
var sd_bull_delta = array.new<float>()
var sd_vol_hist   = array.new<float>()
var int sd_count_bear = 0
var int sd_count_bull = 0

// --- 3. CORE LOGIC ---
if sd_enable
    // CALCULATIONS
    sd_vol_hist.push(volume)
    if sd_vol_hist.size() > 1000
        sd_vol_hist.shift()

    sd_avg_vol   = sd_vol_hist.avg()
    sd_extra_vol = volume > sd_avg_vol
    sd_atr       = ta.atr(200) * sd_h_mult
    sd_is_bear   = close < open
    sd_is_bull   = close > open

    // A. Supply Zone Detection
    if sd_is_bear and sd_is_bear[1] and sd_is_bear[2] and sd_extra_vol[1] and sd_count_bear == 0
        float _d = 0.
        for i = 0 to 5
            if sd_is_bull[i]
                sd_count_bear := 1
                sd_bear_boxes.push(box.new(bar_index-i, low[i]+sd_atr, bar_index, low[i], bgcolor=color.new(sd_col_sup, sd_transp), border_color=color.new(sd_col_sup, bd_transp), border_width=2, text_halign=text.align_right, text_size=size.normal))
                sd_bear_delta.push(_d)
                break
            _d += sd_is_bear[i] ? -volume[i] : volume[i]

    if sd_count_bear >= 1
        sd_count_bear := sd_count_bear >= 15 ? 0 : sd_count_bear + 1

    // B. Demand Zone Detection
    if sd_is_bull and sd_is_bull[1] and sd_is_bull[2] and sd_extra_vol[1] and sd_count_bull == 0
        float _d = 0.
        for i = 0 to 5
            if sd_is_bear[i]
                sd_count_bull := 1
                sd_bull_boxes.push(box.new(bar_index-i, high[i], bar_index, high[i]-sd_atr, bgcolor=color.new(sd_col_dem, sd_transp), border_color=color.new(sd_col_dem, bd_transp), border_width=2, text_halign=text.align_right, text_size=size.normal))
                sd_bull_delta.push(_d)
                break
            _d += sd_is_bull[i] ? volume[i] : -volume[i]

    if sd_count_bull >= 1
        sd_count_bull := sd_count_bull >= 15 ? 0 : sd_count_bull + 1

    // C. Zone Management
    _tot_v = math.abs(sd_bear_delta.sum()) + math.abs(sd_bull_delta.sum())
    
    if sd_bear_boxes.size() > 0
        for i = sd_bear_boxes.size() - 1 to 0
            _b = sd_bear_boxes.get(i)
            _val = sd_bear_delta.get(i)
            _b.set_text("Short: " + str.tostring(_val, format.volume) + " | " + str.tostring(math.abs(_val / _tot_v * 100), format.percent))
            _b.set_right(bar_index + sd_zone_len)
            if close > _b.get_top()
                _b.delete(), sd_bear_boxes.remove(i), sd_bear_delta.remove(i)

    if sd_bull_boxes.size() > 0
        for i = sd_bull_boxes.size() - 1 to 0
            _b = sd_bull_boxes.get(i)
            _val = sd_bull_delta.get(i)
            _b.set_text("Long: " + str.tostring(_val, format.volume) + " | " + str.tostring(math.abs(_val / _tot_v * 100), format.percent))
            _b.set_right(bar_index + sd_zone_len)
            if close < _b.get_bottom()
                _b.delete(), sd_bull_boxes.remove(i), sd_bull_delta.remove(i)

    // D. Limit count
    if sd_bear_boxes.size() > 5
        sd_bear_boxes.shift().delete(), sd_bear_delta.shift()
    if sd_bull_boxes.size() > 5
        sd_bull_boxes.shift().delete(), sd_bull_delta.shift()

else
    // Disable cleanup
    if sd_bear_boxes.size() > 0
        for i = sd_bear_boxes.size() - 1 to 0
            sd_bear_boxes.get(i).delete()
        sd_bear_boxes.clear(), sd_bear_delta.clear()
    if sd_bull_boxes.size() > 0
        for i = sd_bull_boxes.size() - 1 to 0
            sd_bull_boxes.get(i).delete()
        sd_bull_boxes.clear(), sd_bull_delta.clear()
    sd_count_bear := 0, sd_count_bull := 0

// ============================================
// ğŸ“Š BTC ATH Golden Cycle ë¹„ì¤‘ ë° íƒ€ê²Ÿ ê³„ì‚°
// ============================================
f_calc_weight(w) =>
    w0 = 1.0
    w1 = w0 * w
    w2 = w1 * w
    w3 = w2 * w
    w4 = w3 * w
    total = w0 + w1 + w2 + w3 + w4
    [w0/total, w1/total, w2/total, w3/total, w4/total]

[wt1, wt2, wt3, wt4, wt5] = f_calc_weight(weight_val)

var float ath = 0.0
ath := math.max(nz(ath, high), high)

step_drop = max_drop_pct / 5
buy_p1 = ath * (1 - step_drop * 1 / 100)
buy_p2 = ath * (1 - step_drop * 2 / 100)
buy_p3 = ath * (1 - step_drop * 3 / 100)
buy_p4 = ath * (1 - step_drop * 4 / 100)
buy_p5 = ath * (1 - step_drop * 5 / 100)

avg_p = strategy.position_avg_price
step_rise = max_rise_pct / 5
sell_p1 = avg_p * (1 + step_rise * 1 / 100)
sell_p2 = avg_p * (1 + step_rise * 2 / 100)
sell_p3 = avg_p * (1 + step_rise * 3 / 100)
sell_p4 = avg_p * (1 + step_rise * 4 / 100)
sell_p5 = avg_p * (1 + step_rise * 5 / 100)

// ============================================
// ğŸ’° ì§„ì… ë° ì²­ì‚° ì œì–´ (Commend ì¶”ê°€)
// ============================================
f_has_id(id) =>
    has = false
    if strategy.opentrades > 0
        for i = 0 to strategy.opentrades - 1
            if strategy.opentrades.entry_id(i) == id
                has := true
                break
    has

has_l1 = f_has_id("L1"), has_l2 = f_has_id("L2"), has_l3 = f_has_id("L3"), has_l4 = f_has_id("L4"), has_l5 = f_has_id("L5")

if inDate
    // ë§¤ìˆ˜: ì§ì´ ë˜ëŠ” ë§¤ë„ê°€ ì™„ë£Œë˜ì–´ í•´ë‹¹ 'Layer'ê°€ ë¹„ì–´ìˆì„ ë•Œë§Œ ì§„ì… (ë¹„ì¤‘ í‘œì‹œ)
    if not has_l1 and low <= buy_p1
        strategy.entry("L1", strategy.long, qty = (strategy.equity * wt1) / buy_p1, comment="L1(" + str.tostring(wt1 * 100, "#.##") + "%)")
    if not has_l2 and low <= buy_p2
        strategy.entry("L2", strategy.long, qty = (strategy.equity * wt2) / buy_p2, comment="L2(" + str.tostring(wt2 * 100, "#.##") + "%)")
    if not has_l3 and low <= buy_p3
        strategy.entry("L3", strategy.long, qty = (strategy.equity * wt3) / buy_p3, comment="L3(" + str.tostring(wt3 * 100, "#.##") + "%)")
    if not has_l4 and low <= buy_p4
        strategy.entry("L4", strategy.long, qty = (strategy.equity * wt4) / buy_p4, comment="L4(" + str.tostring(wt4 * 100, "#.##") + "%)")
    if not has_l5 and low <= buy_p5
        strategy.entry("L5", strategy.long, qty = (strategy.equity * wt5) / buy_p5, comment="L5(" + str.tostring(wt5 * 100, "#.##") + "%)")

    // ë§¤ë„: í‰ë‹¨ê°€ ëŒ€ë¹„ ëª©í‘œ ìƒìŠ¹ë¥  í‘œì‹œ
    if strategy.position_size > 0
        strategy.exit("Ex1", "L1", limit = sell_p1, comment="Ex1(" + str.tostring(step_rise * 1, "#") + "%)")
        strategy.exit("Ex2", "L2", limit = sell_p2, comment="Ex2(" + str.tostring(step_rise * 2, "#") + "%)")
        strategy.exit("Ex3", "L3", limit = sell_p3, comment="Ex3(" + str.tostring(step_rise * 3, "#") + "%)")
        strategy.exit("Ex4", "L4", limit = sell_p4, comment="Ex4(" + str.tostring(step_rise * 4, "#") + "%)")
        strategy.exit("Ex5", "L5", limit = sell_p5, comment="Ex5(" + str.tostring(step_rise * 5, "#") + "%)")

// ============================================
// ğŸ¨ VISUALIZATION (ì‹œê°í™” ìµœì í™”)
// ============================================
// 0. Ichimoku Inputs & Optimization
plot(show_ichi ? ichi_KJ : na, title='Neo-Ichi ê¸°ì¤€ì„ ', color=color.new(color.yellow, 0), linestyle=plot.linestyle_dotted, linewidth=2) 
ichi_pA = plot(show_ichi ? ichi_SA : na, title='Neo-Ichi ì„ í–‰ìŠ¤íŒ¬A', color=color.new(ichi_color, 0), offset=ichi_offset, linewidth=1) 
ichi_pB = plot(show_ichi ? ichi_SB : na, title='Neo-Ichi ì„ í–‰ìŠ¤íŒ¬B', color=color.new(ichi_color, 0), offset=ichi_offset, linewidth=4) 
fill(ichi_pA, ichi_pB, color=color.new(ichi_color, 70), title='Neo-Ichi êµ¬ë¦„ëŒ€')

// GMA Band Plot
p_ma1 = plot(showGMI ? gmi_ma1 : na, color=color.new(gmi_trendCol, 10), title="Geometric Fast Line", linewidth=1)
p_ma2 = plot(showGMI ? gmi_ma2 : na, color=color.new(gmi_trendCol, 10), title="Geometric Slow  Line", linewidth=4)
plot(showGMI ? gmi_mean : na, color=color.green, title="Geometric Mean (GM)", linewidth=2)
fill(p_ma1, p_ma2, color=color.new(gmi_trendCol, 70), title="GMI Trend Fill")


// BTC ATH Golden Cycle / ë§ˆì§€ë§‰ ê±°ë˜(íŠ¹íˆ ë§¤ë„) ë°œìƒ ì‹œì  ì¶”ì 
var int last_sell_bar = 0
if strategy.position_size[1] > strategy.position_size
    last_sell_bar := bar_index

// í˜„ì¬ ë³´ìœ  ë¬¼ëŸ‰ ì¤‘ ê°€ì¥ ë¨¼ì € ë„ë‹¬í•  íƒ€ê²Ÿ ì„ ì •
float current_sell_target = na
if has_l1
    current_sell_target := sell_p1
else if has_l2
    current_sell_target := sell_p2
else if has_l3
    current_sell_target := sell_p3
else if has_l4
    current_sell_target := sell_p4
else if has_l5
    current_sell_target := sell_p5

// ì‹œê°í™” ì¡°ê±´: í¬ì§€ì…˜ì´ ìˆê³ , ë§ˆì§€ë§‰ ë§¤ë„ ì‹œì  ì´í›„ë¶€í„°ë§Œ í‘œì‹œ
show_sell_line = strategy.position_size > 0 and bar_index >= last_sell_bar

plot(ath, "ATH", color.new(color.gray, 30), style=plot.style_stepline, linewidth=1)
// ë‹¤ìŒ ë§¤ìˆ˜ ë¼ì¸
next_buy = not has_l1 ? buy_p1 : not has_l2 ? buy_p2 : not has_l3 ? buy_p3 : not has_l4 ? buy_p4 : not has_l5 ? buy_p5 : na
plot(next_buy, "Next Buy", color.new(color.green, 0), style=plot.style_linebr, linewidth=1)
// ë‹¤ìŒ ë§¤ë„ ë¼ì¸ (ìˆ˜ì •ëœ ë¡œì§)
plot(show_sell_line ? current_sell_target : na, "Next Sell", color.new(color.orange, 0), style=plot.style_linebr, linewidth=1)
plot(strategy.position_size > 0 ? avg_p : na, "Avg Price", color.yellow, linestyle=plot.linestyle_dotted, linewidth=1)