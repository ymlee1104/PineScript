//@version=6
indicator("üöøLiquidation Heatmap[Modual]", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=100)

// =============================================================================
// [MODULE 1] CONFIGURATION & INPUTS
// =============================================================================
grp_disp    = "Show: Display Settings"
showInd     = input.bool(true, "Indicator", inline='sh', group=grp_disp)
keepTouch   = input.bool(false, "Touched Pockets", inline='sh', group=grp_disp)
showScale   = input.bool(false, "Scale", inline='sh', group=grp_disp)
extBars     = input.int(0, "Bar Extension", minval=0, inline='sh', group=grp_disp)

grp_calc    = "Calculation Logic"
calcMode    = input.string("Vol x Range", "Calculation Mode", options=["Volume", "Range", "Vol x Range"], inline='cal1', group=grp_calc)
lookback    = input.int(480, "Lookback Length", minval=100, maxval=5000, inline='cal1', group=grp_calc)
minIntensity= input.float(0.1, "Min Intensity (M)", step=0.1, inline='inten', group=grp_calc) * 1000000
mergeDist   = input.float(0.05, "Label Merge %", step=0.01, inline='inten', group=grp_calc)
atrLen      = input.int(1440, "ATR Period", inline='atr', group=grp_calc)
atrMult     = input.float(1.9, "ATR Band (%)", step=0.1, inline='atr', group=grp_calc) / 10.0
swing1      = input.int(2, "1st Swing Width (Sensitive)", minval=1, maxval=50, group=grp_calc,
              tooltip="Îã®Í∏∞Ï†ÅÏù∏ 'Ï†ÑÏà†Ï†Å' ÏßÑÏûÖ/Ï≤≠ÏÇ∞ ÏûêÎ¶¨Î•º Ï∞æÏäµÎãàÎã§. Í∞íÏù¥ ÏûëÏùÑÏàòÎ°ù ÎØºÍ∞êÌï©ÎãàÎã§.\n\n‚Ä¢ Ïä§Ï∫òÌïë/Îã®ÌÉÄ: 3 (ÎØºÍ∞êÌòï)\n‚Ä¢ Ïä§Ïúô/Ï∂îÏÑ∏Îß§Îß§: 5 (ÏïàÏ†ïÌòï)")
swing2      = input.int(10, "2nd Swing Width (Robust)", minval=0, maxval=50, group=grp_calc,
              tooltip="Ïû•Í∏∞Ï†ÅÏù∏ 'Ï†ÑÎûµÏ†Å' Ï£ºÏöî ÏßÄÏßÄ/Ï†ÄÌï≠ ÎùºÏù∏ÏùÑ Ï∞æÏäµÎãàÎã§. ÌÅ∞ ÌùêÎ¶ÑÏùò Î™©ÌëúÍ∞Ä ÌôïÏù∏Ïö©ÏûÖÎãàÎã§.\n\n‚Ä¢ Ïä§Ï∫òÌïë/Îã®ÌÉÄ: 10 (Îã®Í∏∞ Ï§ëÏöî Îß§Î¨ºÎåÄ)\n‚Ä¢ Ïä§Ïúô/Ï∂îÏÑ∏Îß§Îß§: 20 (Î©îÏù¥Ï†Ä Îß§Î¨ºÎåÄ)\n(0ÏúºÎ°ú ÏÑ§Ï†ï Ïãú ÎπÑÌôúÏÑ±)")

grp_style   = "Style & Colors"
useManScale = input.bool(true, "Use Custom Scale", inline='st0', group=grp_style)
valMax      = input.float(3.0, "Scale Max (M)", inline='sc1', group=grp_style) * 1000000
valMin      = input.float(0.0, "Scale Min (M)", inline='sc1', group=grp_style) * 1000000
contrast    = input.float(0.1, "Auto Scale Contrast", step=0.1, inline='sc2', group=grp_style)
touchAlpha  = input.int(85, "Touched Transparency", minval=0, maxval=100, inline='sc2', group=grp_style)
colLong     = input.color(color.rgb(1, 203, 254, 1), "Long Color", inline='col', group=grp_style)
colShort    = input.color(color.rgb(254, 0, 220), "Short Color", inline='col', group=grp_style)
offsetPct   = input.float(0.00, "Price Offset (%)", step=0.05, inline='col', group=grp_style)

// =============================================================================
// [MODULE 2] DATA STRUCTURES (TYPES)
// =============================================================================
type Pocket
    box     id          
    int     startTime   
    int     startBar    
    float   top         
    float   bot         
    float   vol         
    int     side        
    bool    isHit       
    bool    isFrozen    
    int     frozenTime  

// =============================================================================
// [MODULE 3] UTILITY & VISUALIZATION
// =============================================================================
method formatVolume(float val) =>
    string res = ""
    if val >= 1000000000
        res := str.tostring(val / 1000000000, "#,###.#") + "B"
    else if val >= 1000000
        res := str.tostring(val / 1000000, "#,###.#") + "M"
    else if val >= 1000
        res := str.tostring(val / 1000, "#,###.#") + "K"
    else
        res := str.tostring(val, "#,###.#")
    res

calcHeatColor(float w, int side, float vMin, float vMax, bool isTouched) =>
    baseColor = side == 1 ? colLong : colShort
    safeMax = math.max(vMax, vMin + 1.0)
    rng     = safeMax - vMin
    norm    = rng != 0 ? math.max(0.0, math.min((w - vMin) / rng, 1.0)) : 0.0
    effContrast = useManScale ? 1.0 : contrast
    adj         = math.pow(norm, effContrast)
    finalCol    = color.from_gradient(adj, 0.0, 1.0, color.new(baseColor, 90), color.new(baseColor, 0))
    if isTouched
        color.new(baseColor, touchAlpha)
    else
        finalCol

// =============================================================================
// [MODULE 4] POCKET MANAGER (METHODS)
// =============================================================================
var array<Pocket> pockets = array.new<Pocket>()

method update(Pocket this, float vMin, float vMax, int currentBar, int currentTime) =>
    bool shouldDelete = (currentBar - this.startBar) > lookback
    if not shouldDelete
        if not this.isFrozen
            this.id.set_left(this.startTime)
            this.id.set_right(currentTime + nz(currentTime - currentTime[1], 0) * extBars)
        else
            this.id.set_right(this.frozenTime)
        
        col = calcHeatColor(this.vol, this.side, vMin, vMax, this.isHit)
        this.id.set_bgcolor(col)
        if this.isHit
            this.id.set_border_color(color.new(col, touchAlpha))
        else
            this.id.set_border_color(na)
    shouldDelete

method checkTouch(Pocket this, float highPrice, float lowPrice, int currentTime) =>
    bool touched = false
    if not this.isHit and not this.isFrozen
        mid = (this.top + this.bot) * 0.5
        if (this.side == 1 and lowPrice <= mid) or (this.side == -1 and highPrice >= mid)
            touched := true
            if keepTouch
                this.isHit      := true
                this.isFrozen   := true
                this.frozenTime := currentTime
                this.id.set_right(currentTime)
            else
                this.isHit := true 
    touched

// ÏãúÍ∞Ñ(Bar Index) Í∏∞Î∞ò Ï§ëÎ≥µ Î∞©ÏßÄ
isDuplicateEvent(int barIdx, int side) =>
    bool found = false
    if pockets.size() > 0
        for i = pockets.size() - 1 to 0
            p = pockets.get(i)
            if p.startBar == barIdx and p.side == side
                found := true
                break
    found

// [ÌïµÏã¨ ÏàòÏ†ï] addPocketÏù¥ srcSeries(Ï†ÑÏ≤¥ Í±∞ÎûòÎüâ Îç∞Ïù¥ÌÑ∞)Î•º Î∞õÏïÑÏÑú Í≥ºÍ±∞ ÏãúÏ†êÏùÑ Ï°∞ÌöåÌï®
addPocket(float rawPrice, int width, int side, float srcVal, float band, float vMin, float vMax) =>
    // 1. PivotÏù¥ Ï°¥Ïû¨ÌïòÍ≥† (naÍ∞Ä ÏïÑÎãò)
    if not na(rawPrice)
        // 2. [ÏàòÏ†ï] Í∞ïÎèÑ(Intensity) Ï≤¥ÌÅ¨Î•º Ïó¨Í∏∞ÏÑú ÏàòÌñâ!
        // srcValÏùÄ ÌòÑÏû¨ Î¥âÏùò Í∞íÏù¥ ÏïÑÎãàÎùº, ÌîºÎ≤óÏù¥ Î∞úÏÉùÌñàÎçò Í≥ºÍ±∞ ÏãúÏ†ê(width Ï†Ñ)Ïùò Í∞íÏù¥Ïñ¥Ïïº Ìï®.
        // ÌïòÏßÄÎßå Ìò∏Ï∂úÌï† Îïå Ïù¥ÎØ∏ liqM[width]Í∞Ä ÎÑòÏñ¥Ïò§ÏßÄ ÏïäÏïòÎã§Î©¥ Ïó¨Í∏∞ÏÑú Ï≤òÎ¶¨ Î∂àÍ∞Ä.
        // Îî∞ÎùºÏÑú Ìò∏Ï∂úÎ∂ÄÏóêÏÑú Ï†ïÌôïÌïú Í≥ºÍ±∞ Í∞íÏùÑ ÎÑòÍ≤®Ï§òÏïº Ìï®. (ÏïÑÎûò Main Logic Ï∞∏Ï°∞)
        
        if srcVal >= minIntensity // <-- Ïò¨Î∞îÎ•∏ ÏãúÏ†êÏùò Í±∞ÎûòÎüâÏù¥ Í∏∞Ï§ÄÏùÑ ÎÑòÎäîÏßÄ ÌôïÏù∏
            targetBar = bar_index - width 
            
            if not isDuplicateEvent(targetBar, side)
                basePrice = side == -1 ? rawPrice * (1 + offsetPct / 100.0) : rawPrice * (1 - offsetPct / 100.0)
                topP      = side == -1 ? basePrice + band : basePrice
                botP      = side == -1 ? basePrice : basePrice - band
                
                b = box.new(time[width], topP, time, botP, xloc=xloc.bar_time, border_color=na)
                p = Pocket.new(b, time[width], targetBar, topP, botP, srcVal, side, false, false, na)
                pockets.push(p)

// =============================================================================
// [MODULE 5] MAIN EXECUTION & AGGREGATION
// =============================================================================
var table scaleTbl = table.new(position.middle_right, 1, 24)

if showInd
    // 1. Í∞ïÎèÑ Í≥ÑÏÇ∞
    rangeM = (high - low) * 100.0
    volM   = ta.cum(volume) <= 1 ? rangeM : volume
    liqM   = switch calcMode
        "Range"       => rangeM
        "Vol x Range" => volM * rangeM
        => volM

    // 2. ÌîºÎ≤ó Ï†ÑÏó≠ Í≥ÑÏÇ∞
    ph1 = ta.pivothigh(high, swing1, swing1)
    pl1 = ta.pivotlow(low, swing1, swing1)
    
    ph2 = ta.pivothigh(high, swing2, swing2)
    pl2 = ta.pivotlow(low, swing2, swing2)

    // 3. Ïä§ÏºÄÏùº Í≥ÑÏÇ∞
    autoMax = nz(ta.highest(liqM, lookback), liqM)
    autoMin = nz(ta.lowest(liqM, lookback), liqM)
    if autoMin == autoMax
        autoMin := autoMin * 0.9
    
    curMax = useManScale ? valMax : autoMax
    curMin = useManScale ? valMin : autoMin
    curBand = ta.atr(atrLen) * atrMult

    // 4. Ìè¨Ïºì Ï∂îÍ∞Ä ÏãúÎèÑ [Í∞ÄÏû• Ï§ëÏöîÌïú ÏàòÏ†ï Î∂ÄÎ∂Ñ]
    // Í∏∞Ï°¥Ïùò 'if liqM >= minIntensity' Ï°∞Í±¥ÏùÑ Ï†úÍ±∞ÌñàÏäµÎãàÎã§.
    // ÎåÄÏã† Ìï®ÏàòÏóê 'liqM[swing1]' (Í≥ºÍ±∞ Í∞í)ÏùÑ Ï†ÑÎã¨Ìï©ÎãàÎã§.
    
    // Swing 1
    addPocket(ph1, swing1, -1, liqM[swing1], curBand, curMin, curMax)
    addPocket(pl1, swing1,  1, liqM[swing1], curBand, curMin, curMax)
    
    // Swing 2
    if swing2 > 0 and swing2 != swing1
        addPocket(ph2, swing2, -1, liqM[swing2], curBand, curMin, curMax)
        addPocket(pl2, swing2,  1, liqM[swing2], curBand, curMin, curMax)

    // 5. Ìè¨Ïºì Í¥ÄÎ¶¨
    if pockets.size() > 0
        for i = pockets.size() - 1 to 0
            p = pockets.get(i)
            isTouchedNow = p.checkTouch(high, low, time)
            killByTouch  = isTouchedNow and not keepTouch
            killByAge    = p.update(curMin, curMax, bar_index, time)
            
            if killByTouch or killByAge
                p.id.delete()
                pockets.remove(i)

    // 6. [Aggregator] Î≥ëÌï© Î∞è Í∑∏Î¶¨Í∏∞ (Last Bar Only)
    if barstate.islast
        if showScale
            table.cell(scaleTbl, 0, 0, "Max\n" + curMax.formatVolume(), text_color=color.white, bgcolor=color.new(color.black, 80), text_size=size.small)
            for i = 1 to 22
                c = color.from_gradient(i - 1, 0, 21, color.new(colShort, 5), color.new(colLong, 5))
                table.cell(scaleTbl, 0, i, "", bgcolor=c, height=1.5)
            table.cell(scaleTbl, 0, 23, "Min\n" + curMin.formatVolume(), text_color=color.white, bgcolor=color.new(color.black, 80), text_size=size.small)
        else
            table.clear(scaleTbl, 0, 0, 0, 23)

        var label[] activeLabels = array.new<label>()
        var box[]   mergedBoxes  = array.new<box>()
        for l in activeLabels
            l.delete()
        activeLabels.clear()
        for b in mergedBoxes
            b.delete()
        mergedBoxes.clear()

        // Î≥ëÌï© Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
        float[] yList = array.new<float>()
        int[]   idxList = array.new<int>()
        for i = 0 to pockets.size() - 1
            p = pockets.get(i)
            if not p.isHit
                yList.push((p.top + p.bot) / 2)
                idxList.push(i)

        // Ï†ïÎ†¨ Î∞è Î≥ëÌï© Ïã§Ìñâ
        if yList.size() > 0
            sortedIndices = yList.sort_indices()
            firstIdx = sortedIndices.get(0)
            pFirst   = pockets.get(idxList.get(firstIdx))
            
            grpVol = pFirst.vol
            grpTop = pFirst.top
            grpBot = pFirst.bot
            grpY   = (grpTop + grpBot) / 2
            grpSide= pFirst.side
            
            for k = 0 to sortedIndices.size() - 1
                isLastItem = (k == sortedIndices.size() - 1)
                
                if not isLastItem
                    nextK   = k + 1
                    nextIdx = sortedIndices.get(nextK)
                    realIdx = idxList.get(nextIdx)
                    pNext   = pockets.get(realIdx)
                    
                    nextY   = (pNext.top + pNext.bot) / 2
                    dist    = math.abs(nextY - grpY) / close * 100
                    
                    if dist <= mergeDist
                        // Î≥ëÌï©: Î≥ºÎ•® Ìï©ÏÇ∞
                        grpVol  += pNext.vol
                        grpTop  := math.max(grpTop, pNext.top)
                        grpBot  := math.min(grpBot, pNext.bot)
                        grpY    := ((grpY * (grpVol - pNext.vol)) + (nextY * pNext.vol)) / grpVol
                        if pNext.vol > (grpVol - pNext.vol) 
                            grpSide := pNext.side
                        pNext.id.set_right(time)
                    else
                        // Î≥ëÌï© Ï¢ÖÎ£å -> Í∑∏Î¶¨Í∏∞
                        fCol = calcHeatColor(grpVol, grpSide, curMin, curMax, false)
                        lx   = time + nz(time - time[1], 0) * (extBars + 1)
                        mb   = box.new(time, grpTop, lx, grpBot, xloc=xloc.bar_time, border_color=na, bgcolor=fCol)
                        mergedBoxes.push(mb)
                        lbl  = label.new(lx, grpY, grpVol.formatVolume(), xloc=xloc.bar_time, yloc=yloc.price, color=fCol, style=label.style_label_left, textcolor=color.white, size=size.normal)
                        activeLabels.push(lbl)
                        
                        // ÏÉà Í∑∏Î£π ÏãúÏûë
                        grpVol := pNext.vol
                        grpTop := pNext.top
                        grpBot := pNext.bot
                        grpY   := nextY
                        grpSide:= pNext.side
                        pNext.id.set_right(time)
                else
                    // ÎßàÏßÄÎßâ ÏöîÏÜå Ï≤òÎ¶¨
                    fCol = calcHeatColor(grpVol, grpSide, curMin, curMax, false)
                    lx   = time + nz(time - time[1], 0) * (extBars + 1)
                    mb   = box.new(time, grpTop, lx, grpBot, xloc=xloc.bar_time, border_color=na, bgcolor=fCol)
                    mergedBoxes.push(mb)
                    lbl  = label.new(lx, grpY, grpVol.formatVolume(), xloc=xloc.bar_time, yloc=yloc.price, color=fCol, style=label.style_label_left, textcolor=color.white, size=size.normal)
                    activeLabels.push(lbl)