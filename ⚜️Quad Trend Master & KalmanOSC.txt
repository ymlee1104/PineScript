//@version=6
indicator("âšœï¸Quad Trend Master & KalmanOSC", overlay=true)

// ì‹œì‘-ì¢…ë£Œ
grp_time        = "ì‹œì‘ì¼-ì¢…ë£Œì¼ ë²”ìœ„"
start_time      = input.time(timestamp("2026-01-01 00:00 +0900"), 'ì‹œì‘ì¼', inline='t2', group=grp_time)
end_time        = input.time(timestamp("2099-12-31 00:00 +0900"), 'ì¢…ë£Œì¼', inline='t2', group=grp_time)
inDate          = time >= start_time and time <= end_time

// ==============================================================================
// 1. í†µí•© ì…ë ¥ ì„¤ì • (Inputs)
// ==============================================================================
// --- ZigZag Trend_Color Inputs ---
grp_zigzag = "1. Zig Zag Line"
useZig = input.bool(true, "ZigZag", inline='zigzag', group=grp_zigzag)
Zigdev = input.float(0.5, "ì´ê²©", step=0.1, inline='zigzag', group=grp_zigzag) / 100
Zigthk = input.int(1, "ë‘ê»˜", inline='zigzag', group=grp_zigzag)
ZigtxtSz = input.string(size.normal, "í¬ê¸°", options=[size.tiny, size.small, size.normal, size.large], inline='zigzag', group=grp_zigzag)

// --- MTF Tillson T3 Inputs ---
grp_t3      = "2. MTF Tillson T3"
use_t3      = input.bool(true, "T3ì‚¬ìš©", inline='mtf_t3', group=grp_t3)
res_t3      = input.timeframe('', "", inline='mtf_t3', group=grp_t3)
len_t3      = input.int(8, "ê¸¸ì´", inline='mtf_t3', group=grp_t3)
vol_t3      = input.float(0.7, "ë³¼ë¥¨ íŒ©í„°", inline='mtf_t3', group=grp_t3)

// --- JMA Inputs ---
grp_jma     = "3. Jurik Moving Average (JMA)"
use_jma     = input.bool(false, "JMAì‚¬ìš©", inline='jma', group=grp_jma)
len_jma     = input.int(30, "ê¸¸ì´", inline='jma', group=grp_jma)
phase_jma   = input.int(50, "ìœ„ìƒ", inline='jma', group=grp_jma)
pow_jma     = input.float(2, "íŒŒì›Œ", inline='jma', group=grp_jma)

// --- ALMA Inputs ---
grp_alma    = "4. ALMA Trend"
use_alma    = input.bool(false, "ALMAì‚¬ìš©", inline='alma1', group=grp_alma)
src_alma    = input.source(close, "ALMA Source", inline='alma1', group=grp_alma)
len_alma    = input.int(30, "ê¸¸ì´", minval=1, inline='alma2', group=grp_alma)
off_alma    = input.float(0.85, "ì˜¤í”„ì…‹", minval=0.0001, inline='alma2', group=grp_alma)
sig_alma    = input.int(6, "ì‹œê·¸ë§ˆ", minval=1, inline='alma2', group=grp_alma)

// --- Range Filter Inputs ---
grp_rf      = "5. Range Filter"
use_rf      = input.bool(false, "RFì‚¬ìš©", inline='rf1', group=grp_rf)
src_rf      = input.source(close, "ì†ŒìŠ¤", inline='rf1', group=grp_rf)
per_rf      = input.int(240, "ê¸°ê°„", minval=1, inline='rf1', group=grp_rf)
mult_rf     = input.float(6.0, "ìŠ¹ìˆ˜", minval=0.1, step=0.1, inline='rf1', group=grp_rf)

// --- Line width Settings ---
grp_lineW   = 'Lines width Settings'
width_line1 = input.int(2, "Tillson/Jurik/ALMA", inline='line', group=grp_lineW)
width_line2 = input.int(4, "Range Filter", inline='line', group=grp_lineW)

// --- Trend Color Settings ---
grp_color   = 'Trend Color Settings'
col_t3_up   = input.color(color.green, "MTF Tillson T3", inline='coup', group=grp_color)
col_jma_up  = input.color(color.green, "Jurik MA", inline='coup', group=grp_color)
col_alma_up = input.color(color.aqua, "ALMA", inline='coup', group=grp_color)
col_rf_up   = input.color(color.new(#00e676, 0), "Range Filter", inline='coup', group=grp_color)

col_t3_dn   = input.color(color.fuchsia, "MTF Tillson T3", inline='codn', group=grp_color)
col_jma_dn  = input.color(color.red, "Jurik MA", inline='codn', group=grp_color)
col_alma_dn = input.color(color.fuchsia, "ALMA", inline='codn', group=grp_color)
col_rf_dn   = input.color(color.new(#ff5252, 0), "Range Filter", inline='codn', group=grp_color)

// ==============================================================================
// 0. ZigZag Trend_Color Calculation ---
// ==============================================================================
var line lLine = na, var label lLbl = na, var int dir = 0 
var float lastP = close, var float startP = close, var int lastIdx = bar_index

if useZig and inDate
    bool isUp = dir >= 0
    float target = isUp ? high : low
    bool extCond = isUp ? high > lastP : low < lastP
    bool revCond = isUp ? low < lastP * (1 - Zigdev) : high > lastP * (1 + Zigdev)

    if extCond // [ì¶”ì„¸ ì§€ì†] ê³ ì /ì €ì  ê°±ì‹  ì‹œ ë¼ì¸ ë° ë¼ë²¨ ì—°ì¥
        lastP := target, lastIdx := bar_index
        line.set_xy2(lLine, lastIdx, lastP), label.set_xy(lLbl, lastIdx, lastP)
        label.set_text(lLbl, str.tostring((lastP - startP) / startP * 100, format.percent))
        
    else if revCond // [ì¶”ì„¸ ë°˜ì „] ìƒˆë¡œìš´ ë¼ì¸ ë° ë¼ë²¨ ìƒì„±
        startP := lastP, lastP := isUp ? low : high // ì‹œì‘ì  ì €ì¥ í›„ í˜„ì¬ê°€ ê°±ì‹ 
        color c = isUp ? color.red : color.green // ë°˜ì „ë  ìƒ‰ìƒ ê²°ì • (ìƒìŠ¹ì¤‘ì´ë©´ í•˜ë½ìƒ‰ìœ¼ë¡œ)
        lLine := line.new(lastIdx, startP, bar_index, lastP, color=c, width=Zigthk)
        lLbl  := label.new(bar_index, lastP, str.tostring((lastP-startP)/startP*100, format.percent),
                 style=isUp?label.style_label_up:label.style_label_down, color=color.new(color.white,100), textcolor=c, size=ZigtxtSz)
        lastIdx := bar_index, dir := isUp ? -1 : 1 // ì¸ë±ìŠ¤ ì €ì¥ ë° ë°©í–¥ ì „í™˜

// ==============================================================================
// 2. ì „ì—­ ë³€ìˆ˜ ì„ ì–¸ (Global Scope Declaration)
// ==============================================================================
// [MTF T3 Variables]
var bool  t3_upTrend    = false // false ì´ˆê¸°í™” (const ì—ëŸ¬ ë°©ì§€)
float     t3_final      = na    // Security ê²°ê³¼ ì €ì¥ìš© (ë§¤ í‹± ê°±ì‹ ë˜ë¯€ë¡œ var ë¶ˆí•„ìš”)

// [JMA Variables]
var float jma_val       = 0.0
var float jma_e0        = 0.0
var float jma_e1        = 0.0
var float jma_e2        = 0.0

// [ALMA Variables]
float     alma_val      = na    // ê²°ê³¼ ì €ì¥ìš©

// [Range Filter Variables]
var float rf_trend      = na
var int   rf_direction  = 0
var float rf_high_band  = na
var float rf_low_band   = na
var bool  rf_isLong     = false
var bool  rf_isShort    = false


// ==============================================================================
// 3. ì§€í‘œë³„ ë¡œì§ ê³„ì‚° (Calculation Logic)
// ==============================================================================
// ------------------------------------------------------------------------------
// 3.1 MTF Tillson T3 Logic
// ------------------------------------------------------------------------------
float e1_t3 = ta.ema((high + low + 2 * close) / 4, len_t3)
float e2_t3 = ta.ema(e1_t3, len_t3)
float e3_t3 = ta.ema(e2_t3, len_t3)
float e4_t3 = ta.ema(e3_t3, len_t3)
float e5_t3 = ta.ema(e4_t3, len_t3)
float e6_t3 = ta.ema(e5_t3, len_t3)

if use_t3 and inDate
    // T3 Components Calculation

    float c1_t3 = -vol_t3 * vol_t3 * vol_t3
    float c2_t3 = 3 * vol_t3 * vol_t3 + 3 * vol_t3 * vol_t3 * vol_t3
    float c3_t3 = -6 * vol_t3 * vol_t3 - 3 * vol_t3 - 3 * vol_t3 * vol_t3 * vol_t3
    float c4_t3 = 1 + 3 * vol_t3 + vol_t3 * vol_t3 * vol_t3 + 3 * vol_t3 * vol_t3

    float T3_calc = c1_t3 * e6_t3 + c2_t3 * e5_t3 + c3_t3 * e4_t3 + c4_t3 * e3_t3
    
    // MTF Request
    t3_final := request.security(syminfo.tickerid, res_t3, T3_calc)

    // ì¶”ì„¸ íŒë‹¨ (ìˆ˜í‰ êµ¬ê°„ ìƒ‰ìƒ ìœ ì§€)
    if not na(t3_final)
        if t3_final > t3_final[1]
            t3_upTrend := true
        else if t3_final < t3_final[1]
            t3_upTrend := false
        // ê°™ì„ ê²½ìš° ì´ì „ ìƒíƒœ ìœ ì§€

// ------------------------------------------------------------------------------
// 3.2 JMA Logic
// ------------------------------------------------------------------------------
if use_jma and inDate
    float phaseRatio = phase_jma < -100 ? 0.5 : phase_jma > 100 ? 2.5 : phase_jma / 100 + 1.5
    float beta_jma   = 0.45 * (len_jma - 1) / (0.45 * (len_jma - 1) + 2)
    float alpha_jma  = math.pow(beta_jma, pow_jma)

    // JMA Calculation
    jma_e0 := (1 - alpha_jma) * close + alpha_jma * nz(jma_e0[1])
    jma_e1 := (close - jma_e0) * (1 - beta_jma) + beta_jma * nz(jma_e1[1])
    jma_e2 := (jma_e0 + phaseRatio * jma_e1 - nz(jma_val[1])) * math.pow(1 - alpha_jma, 2) + math.pow(alpha_jma, 2) * nz(jma_e2[1])
    jma_val := jma_e2 + nz(jma_val[1])

// ------------------------------------------------------------------------------
// 3.3 ALMA Logic
// ------------------------------------------------------------------------------
ta_alma=ta.alma(src_alma, len_alma, off_alma, sig_alma)
alma_val := use_alma and inDate ? ta_alma : na

// ------------------------------------------------------------------------------
// 3.4 Range Filter Logic
// ------------------------------------------------------------------------------
int wper_rf     = per_rf * 2 - 1
float avrng_rf  = ta.ema(math.abs(src_rf - src_rf[1]), per_rf)
float smrng_rf  = ta.ema(avrng_rf, wper_rf) * mult_rf

if use_rf and inDate
    float h_band_rf = src_rf + smrng_rf
    float l_band_rf = src_rf - smrng_rf

    if bar_index == 0
        rf_high_band := h_band_rf
        rf_low_band  := l_band_rf
        rf_trend     := src_rf
    else
        rf_low_band  := (src_rf > rf_low_band[1]) ? math.max(l_band_rf, rf_low_band[1]) : l_band_rf
        rf_high_band := (src_rf < rf_high_band[1]) ? math.min(h_band_rf, rf_high_band[1]) : h_band_rf
        
        int prev_dir_rf = rf_direction[1]
        if prev_dir_rf == 1
            rf_direction := (src_rf < rf_low_band[1]) ? -1 : 1
        else
            if prev_dir_rf == -1
                rf_direction := (src_rf > rf_high_band[1]) ? 1 : -1
            else
                rf_direction := 1

        rf_trend := (rf_direction == 1) ? rf_low_band : rf_high_band

    rf_isLong  := (rf_direction == 1) and (rf_direction[1] == -1)
    rf_isShort := (rf_direction == -1) and (rf_direction[1] == 1)


// ==============================================================================
// 4. ì‹œê°í™” (Visualization)
// ==============================================================================
// --- MTF T3 Plot ---
col_t3_line = use_t3 ? (t3_upTrend ? col_t3_up : col_t3_dn) : na
plot(use_t3 ? t3_final : na, color=col_t3_line, linewidth=width_line1, title='MTF T3', editable=false)

// --- JMA Plot ---
col_jma_line = use_jma ? (jma_val > jma_val[1] ? col_jma_up : col_jma_dn) : na
plot(use_jma ? jma_val : na, title='JMA', linewidth=width_line1, color=col_jma_line, editable=false)

// --- ALMA Plot ---
col_alma_line = use_alma ? (alma_val >= alma_val[1] ? col_alma_up : col_alma_dn) : na
p_alma = plot(use_alma ? alma_val : na, title='ALMA', color=col_alma_line, linewidth=width_line1, editable=false)

// --- Range Filter Plot ---
col_rf_line = use_rf ? (rf_direction == 1 ? col_rf_up : col_rf_dn) : na
plot(use_rf ? rf_trend : na, color=col_rf_line, linewidth=width_line2, title="Range Filter Trend", editable=false)
plotshape(use_rf and rf_isLong,  title="RF Long",
  style=shape.labelup,   location=location.belowbar,
  color=col_rf_up, text="RF-L", textcolor=color.white, size=size.tiny, editable=false)
plotshape(use_rf and rf_isShort, title="RF Short",
  style=shape.labeldown, location=location.abovebar,
  color=col_rf_dn, text="RF-S", textcolor=color.white, size=size.tiny, editable=false)


// ==============================================================================
// 5. ì•ŒëŒ ì„¤ì • (Alert Conditions)
// ==============================================================================
// 1) MTF T3 Alerts
// T3ê°€ ìƒìŠ¹ ì¶”ì„¸ë¡œ ì „í™˜(ê³¨ë“ í¬ë¡œìŠ¤) ë˜ëŠ” í•˜ë½ ì¶”ì„¸ë¡œ ì „í™˜(ë°ë“œí¬ë¡œìŠ¤)í•  ë•Œ ì•ŒëŒ ë°œìƒ
bool t3_longCondition  = use_t3 and t3_upTrend and not t3_upTrend[1]
bool t3_shortCondition = use_t3 and not t3_upTrend and t3_upTrend[1]
alertcondition(t3_longCondition, title="âšœï¸MTF T3: Long Entry", message="âšœï¸MTF T3: Long Entry Signal Detected!")
alertcondition(t3_shortCondition, title="âšœï¸MTF T3: Short Entry", message="âšœï¸MTF T3: Short Entry Signal Detected!")

// 2) JMA Alerts
// JMAê°€ ìƒìŠ¹í•˜ê¸° ì‹œì‘(Long) ë˜ëŠ” í•˜ë½í•˜ê¸° ì‹œì‘(Short)í•  ë•Œ ì•ŒëŒ ë°œìƒ
bool jma_rising = jma_val > jma_val[1]
bool jma_longCondition = use_jma and jma_rising and not jma_rising[1]
bool jma_shortCondition = use_jma and not jma_rising and jma_rising[1]
alertcondition(jma_longCondition, title="âšœï¸JMA: Long Entry", message="âšœï¸JMA: Long Entry Signal Detected!")
alertcondition(jma_shortCondition, title="âšœï¸JMA: Short Entry", message="âšœï¸JMA: Short Entry Signal Detected!")

// 3) ALMA Alerts
// ALMAê°€ ìƒìŠ¹í•˜ê¸° ì‹œì‘(Long) ë˜ëŠ” í•˜ë½í•˜ê¸° ì‹œì‘(Short)í•  ë•Œ ì•ŒëŒ ë°œìƒ
bool alma_rising = alma_val >= alma_val[1]
bool alma_longCondition = use_alma and alma_rising and not alma_rising[1]
bool alma_shortCondition = use_alma and not alma_rising and alma_rising[1]
alertcondition(alma_longCondition, title="âšœï¸ALMA: Long Entry", message="âšœï¸ALMA: Long Entry Signal Detected!")
alertcondition(alma_shortCondition, title="âšœï¸ALMA: Short Entry", message="âšœï¸ALMA: Short Entry Signal Detected!")

// 4) Range Filter Alerts
// Range Filterì˜ Long/Short ì‹ í˜¸(ì´ë¯¸ ê³„ì‚°ë¨) ì‚¬ìš©
alertcondition(use_rf and rf_isLong, title="âšœï¸Range Filter: Long Entry", message="âšœï¸Range Filter: Long Entry Signal Detected!")
alertcondition(use_rf and rf_isShort, title="âšœï¸Range Filter: Short Entry", message="âšœï¸Range Filter: Short Entry Signal Detected!")


// ì¶”ì²œ ì´ëª¨ì§€ì½˜
// ğŸ‘‘ (ì™•ê´€ - ìµœê³ , ë§ˆìŠ¤í„°) ğŸ’ (ë‹¤ì´ì•„ëª¬ë“œ - ê²¬ê³ í•¨, ê°€ì¹˜) âšœï¸ (í”Œë¢°ë¥´ ë“œ ë¦¬ìŠ¤ - í´ë˜ì‹í•œ ê³ ê¸‰ìŠ¤ëŸ¬ì›€)
// ğŸ† (íŠ¸ë¡œí”¼ - ìŠ¹ë¦¬, 1ìœ„) 2. ì¶”ì„¸ & ìƒìŠ¹ ëŠë‚Œ ğŸš€ (ë¡œì¼“ - ê°•ë ¥í•œ ì¶”ì„¸) ğŸ“ˆ (ì°¨íŠ¸ ìƒìŠ¹ - ì§ê´€ì )
// ğŸŒŠ (íŒŒë„ - íë¦„, ì›¨ì´ë¸Œ) 3. ì •í™•ë„ & í•µì‹¬ ëŠë‚Œ ğŸ¯ (ì¡°ì¤€ - ì •í™•í•œ íƒ€ì ) âš¡ (ë²ˆê°œ - ë¹ ë¥¸ ë°˜ì‘)
// ğŸ’  (ë‹¤ì´ì•„ëª¬ë“œ ë„íŠ¸ - í†µí•©ëœ ì‹œìŠ¤í…œ ëŠë‚Œ)
